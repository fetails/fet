<!DOCTYPE html>
<html>
    <head>
        <link href="https://fonts.googleapis.com/css?family=Lato&display=swap" rel="stylesheet">
        <script src="js/jquery.min.js"></script>
        <script src="js/dat.gui.min.js"></script>
        <script src="js/stats.js"></script>
        <title>WebGL &bull; Achi</title>
    </head>
    <body>
        <style>
            body, html {
                background-color: #161616;
                font-family: 'Lato', sans-serif;
                margin:0;
                padding:0;
            }
            canvas {
                display:block;
                width:100%;
                height:100vh;
            }
        </style>
        <canvas id="webglex" width="1920" height="1080"></canvas>
        <script type="text/javascript">

        var stats = new Stats();
        stats.showPanel( 0 ); // 0: fps, 1: ms, 2: mb, 3+: custom
        document.body.appendChild( stats.dom );
        
        // ====== Setup canvas gl. ====== //
        let canvas = document.querySelector("#webglex");
        let ogl = canvas.getContext("webgl2");
        if(!ogl)
        {
            alert("Your browser does not support WebGL 2");
        }

        class AchiConfig
        {
            constructor()
            {
                this.message = "achi v0.2";
                this.clearCol = [0,0,0,1];
                this.showLines = false;
                this.animate = false;
                this.alphaModifier = 0.50;
            }
        }

        class AchiVertex
        {
            constructor(buffer)
            {
                this.vertex = buffer;
            }
        }

        class AchiShaderExperimental
        {
            constructor(vertex)
            {
                let gl = ogl;
                this.vdata = vertex;
                let vs = gl.createShader(ogl.VERTEX_SHADER);
                ogl.shaderSource(vs, vertex);
                ogl.compileShader(vs);

                if(!ogl.getShaderParameter(vs, ogl.COMPILE_STATUS))
                {
                    console.log("error.");
                }
            }
        }

        class AchiShader
        {
            constructor(vertex, fragment)
            {
                this.gl = ogl;
                let gl = this.gl;

                let vs = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vs, vertex);
                gl.compileShader(vs);

                let fs = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fs, fragment);
                gl.compileShader(fs);

                let prog = gl.createProgram();
                gl.attachShader(prog, vs);
                gl.attachShader(prog, fs);
                gl.linkProgram(prog);
                gl.validateProgram(prog);
                gl.deleteShader(vs);
                gl.deleteShader(fs);
                this.program = prog;
            }

            uniform_float(name, val)
            {
                let gl = this.gl;
                gl.uniform1f(gl.getUniformLocation(this.program, name), val);
            }

            bind()
            {
                let gl = this.gl;
                gl.useProgram(this.program);
            }

            unbind()
            {
                let gl = this.gl;
                gl.useProgram(null);
            }
        }
        class Achi
        {
            constructor(gl)
            {
                this.gl = gl;
                this.options = new AchiConfig();
            }
            gui()
            {
                let gui = new dat.GUI();
                gui.add(this.options, "message");
                gui.add(this.options, "showLines");
                gui.addColor(this.options, "clearCol");
            }
            clear()
            {
                stats.begin();
                stats.end();
                let gl = this.gl;
                gl.clearColor(this.options.clearCol[0] / 255, this.options.clearCol[1] / 255, this.options.clearCol[2] / 255, this.options.clearCol[3] / 255);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            add(buffer)
            {
                let gl = this.gl;
                this.buffer = buffer.vertex;
                this.vbo = gl.createBuffer();
                
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.buffer), gl.STATIC_DRAW);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
            }
            begin()
            {
                let gl = this.gl;
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo);
                gl.vertexAttribPointer(0, 3, gl.FLOAT, gl.FALSE, 0, 0);
                gl.enableVertexAttribArray(0);
            }
            end()
            {
                let gl = this.gl;
                gl.disableVertexAttribArray(0);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
            }
            render()
            {
                let gl = this.gl;
                if(this.options.showLines)
                    gl.drawArrays(gl.LINE_LOOP, 0, 3);
                else
                    gl.drawArrays(gl.TRIANGLES, 0, 3);
            }
            del()
            {
                let gl = this.gl;
                gl.deleteBuffer(this.vbo);
            }
        };

        let vdata = 
        "#version 300 es\n\n" +
        
        "in vec3 coords;\n" +
        "out vec3 sent_coords;\n\n" +
        
        "void main() {\n" + 
        " gl_Position = vec4(coords, 1.0);\n" +
        " sent_coords = coords;\n" +
        "}";

        let fdata =
        "#version 300 es\n\n" +
        "precision mediump float;\n\n" +

        "out vec4 color;\n" +
        "in vec3 sent_coords;\n" +
        "void main() {\n" +
        " color = vec4(sent_coords.x + 0.25, sent_coords.y + 0.25, 0.40, 1);\n" +
        "}";

        let cfg = new AchiConfig();
        let shader = new AchiShader(vdata, fdata);
        let render = new Achi(ogl);

        render.gui();

        render.clear();

        render.add(new AchiVertex([
            0.0, 0.5, 0.0,
            -0.5, -0.5, 0.0,
            0.5, -0.5, 0.0
        ]));



        let loop = function(time)
        {
            render.clear();
           
            render.begin();
            shader.bind();
            render.render();
            shader.unbind();
            render.end();
            
            requestAnimationFrame( loop );
        };

        loop( 0 );

        </script>
    </body>
</html>